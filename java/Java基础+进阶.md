

# 第一部分 编程基础

## 第一章 编程基础

### 1.1 数据类型

java数据类型包含 基本数据类型 及 引用类型。基本类型都有其对于的数组类型，数组表示固定长度的同种数据类型的多条记录，这些数据在内存中连续存放。除了基本数据类型，其他都是引用类型。

#### 1.1.1 基本类型

| 基本类型 | 包含                                       |
| -------- | ------------------------------------------ |
| 整数类型 | byte/short/int/long，分别占用1/2/4/8个字节 |
| 小数类型 | float/double ，分别占用4/8个字节           |
| 字符类型 | char 单个字符，占用1个字节                 |
| 真假类型 | boolean                                    |

#### 1.1.2 数组类型

##### 赋值形式

```java
1、 int[] aar = {1,2,3};
2、 int[] aar = new int[3];
3、 int[] aar = new int[3];
	aar[0] = 1;
	aar[1] = 2;
	aar[3] = 3;
```



**数组长度确定之后就不可以变。同时，不能在给定初始值的同时给定长度**。如：

````java
int[] aar = new int[3]{1,2,3};
````



数组类型与基本数据类型对比：

> 数组有两块地址，一块用于存储数组内容本身，另一块存储内容的位置。

| 代码                 | 内存地址        | 内存数据                                              |
| -------------------- | :-------------- | :---------------------------------------------------- |
| int a = 100；        | 1000            | 100                                                   |
| int[] aar = {1,2,3}; | 2000   数组地址 | 3000   存储的是一个位置，3000开始的位置才是实际的数据 |
|                      | 3000            | 1                                                     |
|                      | 3004            | 2                                                     |
|                      | 3008            | 3                                                     |

用两块内存空间原因？

```java
int[] aarA={1,2,3};
int[] aarB={4,5,6,7};
aarA = aarB;
```

如果aarA对应的内存空间是直接存储数组内容，将aarB赋值给aarA时，aarA将没有足够的空间去容纳aarB的所有元素。用两块内存空间时，aarA存储的值就变成和aarB一样，存储的都是数组内容  {4，5，6，7}的地址，此后访问aarA与aarB是一样的，aarA的内存空间将会被垃圾回收。因此，**数组的长度不可变，不可变指的是数组的内容空间，一经分配，长度就不能在变了，可以改变的是数组变量的值。**



### 1.2 基本运算

> 基本数据类型的运算包含：算数运算、比较运算、逻辑运算。

#### 1.2.1 算数运算

| 算数运算                 | 说明                       |
| ------------------------ | -------------------------- |
| 取模 %                   | 数学中的取余数             |
| 自增（++） 和 自减（--） | 对自己进行加一或减一的操作 |



#### 1.2.2 自增与自减

| 算数运算 | 说明                                         |
| -------- | -------------------------------------------- |
| a++      | 先用原来的值进行其他操作，然后在对自己做修改 |
| ++a      | 先对自己做修改，在用修改后的值进行其他操作   |

```java
b = a++ -1;
等价于
b = a - 1;
a = a + 1;
```



#### 1.2.3 逻辑运算

| 逻辑运算符  | 说明                                |
| ----------- | ----------------------------------- |
| 与 &        | 同时为 true 时为 true               |
| 或 \|       | 有一个为 true 时为 true             |
| 非 ！       | true 变为 false                     |
| 异或 ^      | 两个相异为true                      |
| 短路与 &&   | && 前为 false 时，忽略后面的运算    |
| 短路或 \|\| | \|\| 前面为 true 时，忽略后面的运算 |



### 1.3 条件执行

##### 三元运算符

```java
判断条件？ 表达式1： 表达式2；
```



##### switch

```java
// 表达式的值只能是 byte、short、int、char
switch (表达式) {
        case 值1：
            代码1；
            break;
        case 值2；
            代码2；
            break;
    	default:
        	代码 n+1；
}
```



### 1.4 循环

> 循环指多次重复执行某些类似的操作。

| 循环形式 | 语法                                                         | 说明                                                         |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| while    | while（conditicon）{ <br /><br />       代码块<br />}        | 条件为true，就一直执行后面的代码                             |
| do/while | do{<br /><br />    代码块<br />}while (condition)            | 不管条件语句是什么，代码块都会至少执行一次，如果条件成立，则继续循环，否则退出循环 |
| for      | for (初始化语句；循环条件； 步进操作) {<br /><br />      循环体<br />} |                                                              |
| foreach  | for (int element: elements){<br /><br />       操作<br />}   | 冒号后面是对数组和集合进行遍历，对于不需要使用索引变量，只是简单遍历的情况，使用更为简洁 |



#### 1.4.1 循环控制

- break

  提前结束循环

- continue

  在循环的过程中，有的代码可能不需要每次循环都执行，这时可通过continue跳出循环体中剩下的代码，继续执行步进操作。



### 1.5 函数

> 使用函数可以减少重复代码和分解负责操作。

##### main函数

```java
public static void main(String[] args){
    ……
}
```

java中的函数放在类中，类可以看作一个容纳函数的容器，即函数放在类中，类中包括多个函数。main函数具有特殊的意义，表示程序的入口，String[] args 表示从控制台接收到的参数，java运行一个程序的时候，会寻找定义的main函数，并从main函数开始执行。

**对于重复的代码，可以定义函数，在需要的地方调用，这样可以减少重复代码。对于复杂的操作，可以将操作分为多个函数，使代码更加易读**。

#### 1.5.1 参数传递

##### 数组

在函数内修改数组中的元素会修改调用者中数组的内容，从**数组长度确定之后就不可以变**可知，数组保存两块内存，一块存储数组内容本身，一块用于存储内容的位置，给数组变量赋值不会影响原有的数组内容本身，而只会**让数组变量指向一个不同的数组内容空间**。

##### 可变长度的参数

当希望参数个数不是固定时，可以在数据类型后面加“ ... ”，在函数内，可变长度参数可以看作是数组，**可变长度参数必须是参数列表的最后一个，一个函数也只能有一个可变长度的参数**。可变长度参数实际上会转化为数组参数，使用可变长度参数主要是简化了代码的书写。

```java
public int sum(int... value){}
```

#### 1.5.2 返回

函数返回值类型为 void 时，也可以使用 return，即 return； ，不用带值，含义是**返回调用方**，只是没有返回值。

函数的返回值最多只有一个，实际情况中，需要返回多个返回值时：

1. 计算一个整数数组中最大的前三个数，需要返回三个结果，可用数组作为返回值。
2. 当需要返回一个复合结果时，如查找一个数组中所有重复出现的字符及出现的次数，可以用对象作为返回值。

#### 1.5.3 重复的命名

每一个函数都有一个名字，这个名字表示这个函数的意义。同一个类中，函数可以重名，但是参数个数不能完全一样，即**要么参数个数不同，要么参数个数相同但是参数类型不一样**。这种被称为**函数重载**。



### 1.6 函数调用

#### 1.6.1 栈

程序执行基本原理：CPU 有一个指令指示器， 指向下一个要执行的指令，要么顺序执行，要么进行跳转（条件跳转或无条件跳转）。

程序从main函数开始顺序执行，函数调用可以看作一个无条件跳转，跳转到对应函数的指令处开始执行，碰到 return 语句或者函数结尾的时候，在执行一次无条件跳转，跳转回调用方，执行调用函数后的下一条指令。

存放数据的内存的地方为 栈，栈是一块内存，栈一般是先进后出，类似于一个桶，往栈中放数据为入栈，最下面的底为栈底，最上面的为栈顶，从栈顶拿出数据通常称为出栈。栈一般是从高位地址向低位地址拓展，换句话说，栈底的内存是最高的，栈顶的是最低的。

计算机主要使用栈来存放函数调用过程中需要的数据，包括参数，返回地址，以及函数定义的局部变量。**main函数的相关数据放在栈的最下面，每调用一次函数，都会将相关函数的数据入栈，调用结束会出栈**。

- 函数中的基本数据类型（参数和函数定义的变量），在函数被调用时才分配，在调用结束后就被释放了。
- 对于数组和引用类型，均有两块内存，一块存放实际的内容，一块存放实际内容的地址，实际内容一般不是分配在栈上的，而是分配在堆（也是内存的一部分）中，但是存放地址的空间是分配在栈上的。堆 由地址和内容组成。对于数组，存放地址的栈空间会随着入栈分配，出栈释放，但实际内容的堆空间不受影响。



# 第二部分 面向对象

## 第二章 类的基础

### 2.1 对象

对象是由基本数据类型、数组和其他对象组合而成的一个东西，以方便对其整体进行操作。为了操作数据，需要把数据放在内存中。内存在程序看来就是一块有**地址编号**的**连续**的空间，CPU对加载的变量的值进行各种运算，运算后的结果又可以赋值给其他变量，保存到内存中。

### 2.2 封装



### 2.3 继承



### 2.4 多态





## 第三章 类的继承







## 第四章 类的拓展





## 第五章 异常



## 第六章 常用基础类





# 第三部分 泛型与容器

## 第七章 泛型



## 第八章 列表和队列



## 第九章 Map 和 Set



## 第十章 堆与优先级队列



## 第十一章 通用容器类和总结



# 第四部分 文件



## 第十二章 文件基本技术



## 第十三章 文件高级技术

### 13.1 常见文件类型处理

#### 13.1.1 Excel 

使用POI类库处理Excel文件，接入方式：

```groovy
dependencies{
	implementation "org.apache.poi:poi:4.0.0"
}
```





#### 13.1.2 HTML

介绍 jsoup HTML分析器，接入方式：

```groovy
dependencies{
 	implementation 'org.jsoup:jsoup:1.11.3'   
}
```



#### 13.1.3 CSV



#### 13.1.4 属性文件



#### 13.1.5 压缩文件



#### 13.1.6 XML

使用 DOM4J 库，接入方式：

```groovy
dependencies{
    implementation group: 'org.dom4j', name: 'dom4j', version: '2.1.1'
}
```







### 13.2 随机读写文件



### 13.3 内存映射文件



### 13.4 标准序列化机制



### 13.5 使用 Jackson 序列化为 JSON/XML/MessagePack



# 第五部分 并发

## 第十四章 并发基础知识



## 第十五章 并发包的基石





## 第十六章 并发容器



## 第十七章 异步任务执行服务



## 第十八章 同步和协作工具类



## 第十九章 并发总结



# 第六部分 动态与函数式编程

##  第二十章 注解与反射

> 使用声明式编程，为应用程序员提供更高级的语言，使程序员可以在更高的抽象层次上思考和解决问题，不是陷于底层的实现细节。
>
> 注解可以提升java语言的表达能力，有效实现应用功能和底层功能的分离，框架/库的程序员可以专注于底层的实现，借助反射实现通用功能，提供注解给应用程序员使用，应用程序员可以专注于应用功能，通过简单的声明式注解与框架/库进行协作。

### 6.1 常用注解

| 注解             | 说明                                                         |
| ---------------- | ------------------------------------------------------------ |
| @Override        | 表示该方法不是当前类首先声明，是在某个父类或实现的接口中声明的 |
| @Deprecated      | 表示对应的代码已经过时，不应该使用它                         |
| @SuppressWarning | 表示压制java的编译警告                                       |

### 6.2 自定义注解

| 元注解     | 注解参数                                                     |
| ---------- | ------------------------------------------------------------ |
| @Target    | Element.TYPE、Element、Method ...                            |
| @Retention | RetentionPolicy.SOURCE, RetentionPolicy.CLASS, RetentionPolicy.RUNTIME |
| @InHerited | 表示继承                                                     |

注解内参数合法类型：基本类型、String、Class、枚举、注解以及这些类型的数组。

#### 查看注解信息

| 方法                   | 说明                                                  |
| ---------------------- | ----------------------------------------------------- |
| getAnnotations         | 获取所有注解                                          |
| getDeclaredAnnotations | 获取所有本元素上直接声明的注解，忽略inHerited来的注解 |
| getAnnotation          | 获取指定类型注解，没有返回 null                       |
| isAnnotationPresent    | 是否有指定注解                                        |



实际上，内部实现时，所有的注解类型都是拓展的 Annotation。Annotation是一个接口，它表示注解

```
public interface Annotation {
	boolean equals (Object obj);
	int hashCode();
	String toString();
	// 返回真正的注解类型
	Class<? extends Annotation> annotationType();
}
```



对于Constructor和Method，他们都有方法参数，而参数也可以有注解，他们均有如下方法：

```java
public Annotation[][] getParameterAnnotations();
```



### 6.3 反射



### 6.4 注解处理器



### 6.5 依赖注入容器





## 第二十一章 动态代理



## 第二十二章 类加载机制



## 第二十三章 正则表达式



## 第二十四章 函数式编程







# 第七部分 进阶

## 第二十五章 Junit 单元测试

### 5.1 测试分类

黑盒测试：给代码给定输入部分参数，代码执行之后能否得到预期的结果。不需要写代码，俗称 ”点点点“

白盒测试：需要写代码，关注程序具体的执行流程。

### 5.2 Junit使用

步骤：

1. 定义测试类（测试用例） 测试类类名格式：测试类+Test 、 包名：xxx.xxx.xxx.test
2. 定义测试方法：可以独立运行  方法名：test+测试方法名 、 返回值：void、参数列表：无参
3. 给方法加注解@Test



##### 常用注解

| 注解    | 说明                                                         |
| ------- | ------------------------------------------------------------ |
| @Before | 所有的测试方法在执行之前均会调用@Before注解的方法执行该方法，用于资源申请及初始化操作。 |
| @After  | 在所有方法测试完成后，都会执行@After注解的方法，用于释放资源 |

#### 5.2.1 基本测试

```java
@Test
public void testAdd() {
    //todo test
}
```



#### 5.2.2 参数化测试

```java
@Test
public void testAdd(){
    
}
```



#### 5.2.3 异常测试



### 