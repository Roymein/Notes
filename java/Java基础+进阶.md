

# 第一部分 编程基础

## 第一章 编程基础

### 1.1 数据类型

java数据类型包含 基本数据类型 及 引用类型。基本类型都有其对于的数组类型，数组表示固定长度的同种数据类型的多条记录，这些数据在内存中连续存放。除了基本数据类型，其他都是引用类型。

#### 1.1.1 基本类型

| 基本类型 | 包含                                       |
| -------- | ------------------------------------------ |
| 整数类型 | byte/short/int/long，分别占用1/2/4/8个字节 |
| 小数类型 | float/double ，分别占用4/8个字节           |
| 字符类型 | char 单个字符，占用1个字节                 |
| 真假类型 | boolean                                    |

#### 1.1.2 数组类型

##### 赋值形式

```java
1、 int[] aar = {1,2,3};
2、 int[] aar = new int[3];
3、 int[] aar = new int[3];
	aar[0] = 1;
	aar[1] = 2;
	aar[3] = 3;
```



**数组长度确定之后就不可以变。同时，不能在给定初始值的同时给定长度**。如：

````java
int[] aar = new int[3]{1,2,3};
````



数组类型与基本数据类型对比：

> 数组有两块地址，一块用于存储数组内容本身，另一块存储内容的位置。

| 代码                 | 内存地址        | 内存数据                                              |
| -------------------- | :-------------- | :---------------------------------------------------- |
| int a = 100；        | 1000            | 100                                                   |
| int[] aar = {1,2,3}; | 2000   数组地址 | 3000   存储的是一个位置，3000开始的位置才是实际的数据 |
|                      | 3000            | 1                                                     |
|                      | 3004            | 2                                                     |
|                      | 3008            | 3                                                     |

用两块内存空间原因？

```java
int[] aarA={1,2,3};
int[] aarB={4,5,6,7};
aarA = aarB;
```

如果aarA对应的内存空间是直接存储数组内容，将aarB赋值给aarA时，aarA将没有足够的空间去容纳aarB的所有元素。用两块内存空间时，aarA存储的值就变成和aarB一样，存储的都是数组内容  {4，5，6，7}的地址，此后访问aarA与aarB是一样的，aarA的内存空间将会被垃圾回收。因此，**数组的长度不可变，不可变指的是数组的内容空间，一经分配，长度就不能在变了，可以改变的是数组变量的值。**



### 1.2 基本运算

> 基本数据类型的运算包含：算数运算、比较运算、逻辑运算。

#### 1.2.1 算数运算

| 算数运算                 | 说明                       |
| ------------------------ | -------------------------- |
| 取模 %                   | 数学中的取余数             |
| 自增（++） 和 自减（--） | 对自己进行加一或减一的操作 |



#### 1.2.2 自增与自减

| 算数运算 | 说明                                         |
| -------- | -------------------------------------------- |
| a++      | 先用原来的值进行其他操作，然后在对自己做修改 |
| ++a      | 先对自己做修改，在用修改后的值进行其他操作   |

```java
b = a++ -1;
等价于
b = a - 1;
a = a + 1;
```



#### 1.2.3 逻辑运算

| 逻辑运算符  | 说明                                |
| ----------- | ----------------------------------- |
| 与 &        | 同时为 true 时为 true               |
| 或 \|       | 有一个为 true 时为 true             |
| 非 ！       | true 变为 false                     |
| 异或 ^      | 两个相异为true                      |
| 短路与 &&   | && 前为 false 时，忽略后面的运算    |
| 短路或 \|\| | \|\| 前面为 true 时，忽略后面的运算 |



### 1.3 条件执行

##### 三元运算符

```java
判断条件？ 表达式1： 表达式2；
```



##### switch

```java
// 表达式的值只能是 byte、short、int、char
switch (表达式) {
        case 值1：
            代码1；
            break;
        case 值2；
            代码2；
            break;
    	default:
        	代码 n+1；
}
```



### 1.4 循环

> 循环指多次重复执行某些类似的操作。

| 循环形式 | 语法                                                         | 说明                                                         |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| while    | while（conditicon）{ <br /><br />       代码块<br />}        | 条件为true，就一直执行后面的代码                             |
| do/while | do{<br /><br />    代码块<br />}while (condition)            | 不管条件语句是什么，代码块都会至少执行一次，如果条件成立，则继续循环，否则退出循环 |
| for      | for (初始化语句；循环条件； 步进操作) {<br /><br />      循环体<br />} |                                                              |
| foreach  | for (int element: elements){<br /><br />       操作<br />}   | 冒号后面是对数组和集合进行遍历，对于不需要使用索引变量，只是简单遍历的情况，使用更为简洁 |



#### 1.4.1 循环控制

- break

  提前结束循环

- continue

  在循环的过程中，有的代码可能不需要每次循环都执行，这时可通过continue跳出循环体中剩下的代码，继续执行步进操作。



### 1.5 函数

> 使用函数可以减少重复代码和分解负责操作。

##### main函数

```java
public static void main(String[] args){
    ……
}
```

java中的函数放在类中，类可以看作一个容纳函数的容器，即函数放在类中，类中包括多个函数。main函数具有特殊的意义，表示程序的入口，String[] args 表示从控制台接收到的参数，java运行一个程序的时候，会寻找定义的main函数，并从main函数开始执行。

**对于重复的代码，可以定义函数，在需要的地方调用，这样可以减少重复代码。对于复杂的操作，可以将操作分为多个函数，使代码更加易读**。

#### 1.5.1 参数传递

##### 数组

在函数内修改数组中的元素会修改调用者中数组的内容，从**数组长度确定之后就不可以变**可知，数组保存两块内存，一块存储数组内容本身，一块用于存储内容的位置，给数组变量赋值不会影响原有的数组内容本身，而只会**让数组变量指向一个不同的数组内容空间**。

##### 可变长度的参数

当希望参数个数不是固定时，可以在数据类型后面加“ ... ”，在函数内，可变长度参数可以看作是数组，**可变长度参数必须是参数列表的最后一个，一个函数也只能有一个可变长度的参数**。可变长度参数实际上会转化为数组参数，使用可变长度参数主要是简化了代码的书写。

```java
public int sum(int... value){}
```

#### 1.5.2 返回

函数返回值类型为 void 时，也可以使用 return，即 return； ，不用带值，含义是**返回调用方**，只是没有返回值。

函数的返回值最多只有一个，实际情况中，需要返回多个返回值时：

1. 计算一个整数数组中最大的前三个数，需要返回三个结果，可用数组作为返回值。
2. 当需要返回一个复合结果时，如查找一个数组中所有重复出现的字符及出现的次数，可以用对象作为返回值。

#### 1.5.3 重复的命名

每一个函数都有一个名字，这个名字表示这个函数的意义。同一个类中，函数可以重名，但是参数个数不能完全一样，即**要么参数个数不同，要么参数个数相同但是参数类型不一样**。这种被称为**函数重载**。



### 1.6 函数调用

#### 1.6.1 栈

程序执行基本原理：CPU 有一个指令指示器， 指向下一个要执行的指令，要么顺序执行，要么进行跳转（条件跳转或无条件跳转）。

程序从main函数开始顺序执行，函数调用可以看作一个无条件跳转，跳转到对应函数的指令处开始执行，碰到 return 语句或者函数结尾的时候，在执行一次无条件跳转，跳转回调用方，执行调用函数后的下一条指令。

存放数据的内存的地方为 栈，栈是一块内存，栈一般是先进后出，类似于一个桶，往栈中放数据为入栈，最下面的底为栈底，最上面的为栈顶，从栈顶拿出数据通常称为出栈。栈一般是从高位地址向低位地址拓展，换句话说，栈底的内存是最高的，栈顶的是最低的。

计算机主要使用栈来存放函数调用过程中需要的数据，包括参数，返回地址，以及函数定义的局部变量。**main函数的相关数据放在栈的最下面，每调用一次函数，都会将相关函数的数据入栈，调用结束会出栈**。

- 函数中的基本数据类型（参数和函数定义的变量），在函数被调用时才分配，在调用结束后就被释放了。
- 对于数组和引用类型，均有两块内存，一块存放实际的内容，一块存放实际内容的地址，实际内容一般不是分配在栈上的，而是分配在堆（也是内存的一部分）中，但是存放地址的空间是分配在栈上的。堆 由地址和内容组成。对于数组，存放地址的栈空间会随着入栈分配，出栈释放，但实际内容的堆空间不受影响。



# 第二部分 面向对象

## 第二章 类的基础

### 2.1 对象

对象是由基本数据类型、数组和其他对象组合而成的一个东西，以方便对其整体进行操作。为了操作数据，需要把数据放在内存中。内存在程序看来就是一块有**地址编号**的**连续**的空间，CPU对加载的变量的值进行各种运算，运算后的结果又可以赋值给其他变量，保存到内存中。



#### 2.1.1 类

> 通过private 封装和隐藏内部实现细节，避免误操作，是计算机程序的一种基本思维

##### Math常用函数

| 函数                            | 功能     | 函数                  | 功能                           |
| ------------------------------- | -------- | --------------------- | ------------------------------ |
| int round (float a )            | 四舍五入 | int abs(int a)        | 绝对值                         |
| double sqrt( double a)          | 平方根   | int max(int a, int b) | 最大值                         |
| double ceil (double a)          | 向上取整 | double log(double a)  | 自然对数                       |
| double floor (double a)         | 向下取整 | double random()       | 产生一个大于等于0小于1的随机数 |
| double pow (double a, double b) | a的b次方 |                       |                                |

##### Arrays常用函数

| 函数                                         | 功能                     |
| -------------------------------------------- | ------------------------ |
| void sort(int[] a)                           | 排序，按升序排           |
| int binarySearch( long[] a, long key)        | 二分查找，数组按升序排列 |
| void fill (int[] a , int val)                | 给所有数组元素赋相同值   |
| int[] copyOf( int[] priginal, int newLength) | 数组复制                 |
| boolean equals(char[] a, char[] b)           | 判断两个数组是否相同     |



#### 2.1.2 自定义数据类型

自定义数据类型是指除了八种基本类型以外的其他类型，用于表示和处理基本类型以外的其他数据。**一个数据类型由其包含的属性以及该类型可以进行的操作组成**，属性又可以分为是类型本身具有的属性，还是一个具体实例具有的属性，同样，操作也可以分为是类型本身可以进行的操作，还是一个具体实例可以进行的操作。因此，一个数据类型由以下部分组成：

- 类型本身具有的属性，通过**类变量**（经常用于表示一个类型中的常量）体现。
- 类型本身可以进行的操作，通过**类方法**体现。
- 类型实例具有的属性，通过**实例变量**体现。
- 类型实例可以进行的操作，通过**实例方法**体现。

类变量 与 实例变量 都叫 **成员变量**，类方法和实例方法都叫**成员方法**。

> final在修饰变量的时候常量，即变量赋值之后就不能在修改了。



#### 2.1.3 初始化代码块

实例变量都有一个默认值，可以在定义变量时就赋值，或将代码放入初始化代码块 {} 中。

静态初始化代码块在类加载的时候执行，这时在任何对象创建之前，且只执行一次。



#### 2.1.4 类和对象的生命周期

1. 在程序运行时，当第一次通过 new 创建一个类的对象时，或者直接通过类名访问类变量和类方法时，java会将类加载进内存，为这个类分配一块空间，这个空间包含类的定义、变量和方法信息，同时还有类的静态变量，并对静态变量赋初始值。
2. 类加载进内存后，一般不会释放，知道程序结束。一般情况下，**类只会加载一次，所有静态变量在内存中只有一份**，**多个实例的 static变量会共享同一块内存区域**。
3. 当通过 new 创建一个对象时，在内存中，会存储这个对象的实例变量值，每 new 一次，就会产生一个对象，就会有一份独立的实例变量。每个对象除了保存实例变量的值外，还可以理解为还保存着对应类型即类的地址，这样就能通过对象知道它的类，访问到类的变量和方法代码。当对象不在被使用时，就会被垃圾回收机制自动释放。

> 具体来说就是：对象和数组一样，有两块内存，保存地址的部分分配在栈中，而保存实际内容的部分分配在堆中。栈中的内存是自动管理的，函数调用入栈就会分配，出栈就会释放。
>
> 堆中的内存是被垃圾回收机制管理的，当没有**活跃变量**指向对象的时候，对应的堆空间就可能会释放，具体释放时间是java虚拟机自己决定的。 **活跃变量**指已加载的类的变量，以及栈中的所有变量。



#### 2.1.5 类的组合

对于一个线来说，是由点组成。**每个类封装其内部细节，对外提供高层次的功能，使其他类在更高层次上考虑和解决问题，使程序设计的一种基本思维**。想想现实问题有那些概念，这些概念有哪些属性，哪些行为，概念之间有什么关系，然后定义类、定义属性、定义方法、定义类之间的关系。概念的属性和行为可能是非常多的，但定义的类只需要包括那些与现实问题有关的就行了。

**分解显示问题中设计的概念以及概念间的关系，将概念表示为多个类，通过类之间的组合表达更为复杂的概念以及概念间的关系**。



#### 2.1.6 封装

**通过对象来访问和操作其内部的数据**是一种基本的面向对象思维。一般而言，不应该将实例变量声明为public，而只应该通过对象的方法对实例变量进行操作。这样可以减少误操作，直接访问变量**没有办法进行参数检查和控制，而通过方法的修改，可以在方法中进行检查**。



#### 2.1.7 包

包有包名，这个名称以点号分隔表示层次结构。带完整包名的类名称称为其**完全限定名**，如String类的完全限定名为 java.lang.String （java是上层包名，lang是下层包名，位于包java.lang下）。java中所有的类和接口都位于 java 或 javax下，java是标准包， javax是拓展包。

如果类不在同一个包内，则必须知道其所在的包。使用方式：一种是通过类的全限定名，另外一种是将用到的类引入当前类。例外是，java.lang 下的类可以直接使用，其他包内的则不行。

通过 import java.util.* 不会引入嵌套包内的类，只会引入该包下的直接类。有一种特殊的导入，称为静态导入，它有一个 static 关键字，可以直接导入类的公共静态方法和成员。

包范围可见性：同一个包指的是同一个直接包，子包下类并不能访问。protected 可见性包括包可见性，也就是说，声明为protected不仅表明子类可以访问，还表明同一个包内的其他类可以访问，即使这些类不是子类也可以。可见性范围从小到大是： **private < 默认（包）< protected < public**。



#### 2.1.8 程序的编译与链接

编译时将源代码文件变成拓展名是 .class 的字节码，这个工作一般是由 javac 命令完成的。

链接是在运行时动态执行的， .class文件不能直接运行，运行的是java虚拟机，虚拟机执行的是 java 命令，这个命令解析 .class 文件，转换为机器能识别的二进制代码，然后运行。所谓链接就是根据引用到的类加载相应的字节码并执行。

java 编译和运行时，都需要指定一个 classpath，即类路径。类路径有多个，对于直接的 class 文件，路径是 class 文件的根目录；对于 jar 包（一种压缩文件），路径是 jar 包的完整名称（包括路径和 jar 包名）。在java 源代码编译时，java编译器会确定引用的每个类的完全限定名，确定的方式是 import 语句和 classpath。如果导入的是完全限定类名，则可以直接比较并确定。如果是模糊导入 （import 带 .*），则根据 classpath找到对应父包，再在父包下寻找是否有对应的类。

java 运行时，会根据类的完全限定名寻找并加载类，寻找的方式就是在类路径中寻找，如果是 class 文件的根目录，则直接查看是否有对应的子目录及文件，如果是 jar 文件，则首先在内存中解析文件，然后在查看是否有对应的类。总结来说就是：**import是编译时概念，用于确定完全限定名，在运行时，只根据完全限定名寻找并加载类，编译和运行时都依赖类路径，类路径中的jar文件会被解压缩用于寻找和加载类。**





## 第三章 类的继承







## 第四章 类的拓展





## 第五章 异常



## 第六章 常用基础类





# 第三部分 泛型与容器

## 第七章 泛型



## 第八章 列表和队列



## 第九章 Map 和 Set



## 第十章 堆与优先级队列



## 第十一章 通用容器类和总结



# 第四部分 文件



## 第十二章 文件基本技术



## 第十三章 文件高级技术

### 13.1 常见文件类型处理

#### 13.1.1 Excel 

使用POI类库处理Excel文件，接入方式：

```groovy
dependencies{
	implementation "org.apache.poi:poi:4.0.0"
}
```





#### 13.1.2 HTML

介绍 jsoup HTML分析器，接入方式：

```groovy
dependencies{
 	implementation 'org.jsoup:jsoup:1.11.3'   
}
```



#### 13.1.3 CSV



#### 13.1.4 属性文件



#### 13.1.5 压缩文件



#### 13.1.6 XML

使用 DOM4J 库，接入方式：

```groovy
dependencies{
    implementation group: 'org.dom4j', name: 'dom4j', version: '2.1.1'
}
```







### 13.2 随机读写文件



### 13.3 内存映射文件



### 13.4 标准序列化机制



### 13.5 使用 Jackson 序列化为 JSON/XML/MessagePack



# 第五部分 并发

## 第十四章 并发基础知识



## 第十五章 并发包的基石





## 第十六章 并发容器



## 第十七章 异步任务执行服务



## 第十八章 同步和协作工具类



## 第十九章 并发总结



# 第六部分 动态与函数式编程

##  第二十章 注解与反射

> 使用声明式编程，为应用程序员提供更高级的语言，使程序员可以在更高的抽象层次上思考和解决问题，不是陷于底层的实现细节。
>
> 注解可以提升java语言的表达能力，有效实现应用功能和底层功能的分离，框架/库的程序员可以专注于底层的实现，借助反射实现通用功能，提供注解给应用程序员使用，应用程序员可以专注于应用功能，通过简单的声明式注解与框架/库进行协作。

### 6.1 常用注解

| 注解             | 说明                                                         |
| ---------------- | ------------------------------------------------------------ |
| @Override        | 表示该方法不是当前类首先声明，是在某个父类或实现的接口中声明的 |
| @Deprecated      | 表示对应的代码已经过时，不应该使用它                         |
| @SuppressWarning | 表示压制java的编译警告                                       |

### 6.2 自定义注解

| 元注解     | 注解参数                                                     |
| ---------- | ------------------------------------------------------------ |
| @Target    | Element.TYPE、Element、Method ...                            |
| @Retention | RetentionPolicy.SOURCE, RetentionPolicy.CLASS, RetentionPolicy.RUNTIME |
| @InHerited | 表示继承                                                     |

注解内参数合法类型：基本类型、String、Class、枚举、注解以及这些类型的数组。

#### 查看注解信息

| 方法                   | 说明                                                  |
| ---------------------- | ----------------------------------------------------- |
| getAnnotations         | 获取所有注解                                          |
| getDeclaredAnnotations | 获取所有本元素上直接声明的注解，忽略inHerited来的注解 |
| getAnnotation          | 获取指定类型注解，没有返回 null                       |
| isAnnotationPresent    | 是否有指定注解                                        |



实际上，内部实现时，所有的注解类型都是拓展的 Annotation。Annotation是一个接口，它表示注解

```
public interface Annotation {
	boolean equals (Object obj);
	int hashCode();
	String toString();
	// 返回真正的注解类型
	Class<? extends Annotation> annotationType();
}
```



对于Constructor和Method，他们都有方法参数，而参数也可以有注解，他们均有如下方法：

```java
public Annotation[][] getParameterAnnotations();
```



### 6.3 反射



### 6.4 注解处理器



### 6.5 依赖注入容器





## 第二十一章 动态代理



## 第二十二章 类加载机制



## 第二十三章 正则表达式



## 第二十四章 函数式编程







# 第七部分 进阶

## 第二十五章 Junit 单元测试

### 5.1 测试分类

黑盒测试：给代码给定输入部分参数，代码执行之后能否得到预期的结果。不需要写代码，俗称 ”点点点“

白盒测试：需要写代码，关注程序具体的执行流程。

### 5.2 Junit使用

步骤：

1. 定义测试类（测试用例） 测试类类名格式：测试类+Test 、 包名：xxx.xxx.xxx.test
2. 定义测试方法：可以独立运行  方法名：test+测试方法名 、 返回值：void、参数列表：无参
3. 给方法加注解@Test



##### 常用注解

| 注解    | 说明                                                         |
| ------- | ------------------------------------------------------------ |
| @Before | 所有的测试方法在执行之前均会调用@Before注解的方法执行该方法，用于资源申请及初始化操作。 |
| @After  | 在所有方法测试完成后，都会执行@After注解的方法，用于释放资源 |

#### 5.2.1 基本测试

```java
@Test
public void testAdd() {
    //todo test
}
```



#### 5.2.2 参数化测试

```java
@Test
public void testAdd(){
    
}
```



#### 5.2.3 异常测试



### 