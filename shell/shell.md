###### echo

> 彩色输出：重置=0，黑色=30，红色=31，绿色=32，黄色=33，蓝色=34，洋红=35，青色=36，白色=37  
> 彩色背景：颜色码是：重置=0，黑色=40，红色=41，绿色=42，黄色=43，蓝色=44，洋红=45，青色=46，白色=47

```
-n 禁用换行（echo会将一个换行符追加到输出文本的尾部）
-e 使用转义序列
e[1;31m   \e[0m颜色重新置回。

echo -e "\e[1;42m Green Background \e[0m"
printf或echo命令的双引号中引用变量值
```



###### 变量与环境变量

> 变量是任何一种编程语言必不可少的组成部分，用于存放各类数据。脚本语言通常不
> 需要在使用变量之前声明其类型。只需要直接赋值就可以了。在Bash中，每一个变量的值
> 都是字符串。无论你给变量赋值时有没有使用引号，值都会以字符串的形式存储。有一些特殊的变量会被shell环境和操作系统环境用来存储一些特别的值，这类变量就被称为环境
> 变量。
>
> 
>
> HOME、PWD、USER、UID、SHELL



```
export 导出特定的变量，用来设置环境变量
```



###### tr

> 转换或删除文件中的字符



##### 数学运算

###### let

> 用于执行一个或多个表达式，变量计算中不需要加上 `$` 来表示变量，如果表达式中包含了空格或其他特殊字符，则必须引起来

```
let num1+num2
```



###### expr

> 求表达式变量的值，一般用于整数值，也可用于字符串。

```
expr 5 + 10
```



###### bc

> 类似基本的计算器, 可以做基本的数学运算

```
echo "5+10" | bc
```

进制转换

```
ibase 是 input base 的缩写，表示输入数字的进制模式 obase 是 output base 的缩写，表示输出数字的进制模式
abc=110011100 
echo "obase=10;ibase=2;$abc" | bc
```



文件描述符与重定向

> 最常见的文件描述符是stdin、stdout和stderr。我们可以将某个文件描述符的内容重定向到另一个
> 文件描述符中。文件描述符是与一个打开的文件或数据流相关联的整数。

> 通过内容过滤将输出重定向到文件是我们从事的基础任务之一。当命令输
> 出文本的时候，这些输出文本有可能是错误信息，也可能是正常的（非错误的）输出信
> 息。单靠查看输出的文本本身，我们没法区分哪些是正常的输出文本，哪些是错误文本。
> 不过，我们可以通过文件描述符来解决这个问题，将那些与特定描述符关联的文本提取出
> 来。

□ 0 —— stdin（标准输入）。
□ 1 —— stdout（标准输出）。
□ 2 —— stderr（标准错误）

> 成功和不成功的命令
> 当一个命令发生错误并退回时，它会返回一个非0的退出状态；而当命令成功完成
> 后，它会返回数字0。退出状态可以从特殊变量 ?中获得（在命令执行语句之后立刻运
> 行echo ?，就可以打印出退出状态）。
>
> cmd 2＞stderr.txt 1＞stdout.txt





###### 管道

> 将两个或者多个命令（程序或者进程）连接到一起，把**一个命令的输出作为下一个命令的输入**，以这种方式连接的两个或者多个命令就形成了**管道（pipe）**。管道使用竖线**`|`**连接多个命令，这被称为管道符



tee

> tee 命令用于读取标准输入的数据，并将其内容输出成文件
>
> （接收到来自stdin的数据。它将stdout的一份副本写入文件）



alias

设置指令的别名


### 执行Shell程序

#### 脚本设置可执行

ls -l 可查看文件的访问权限。r （4）代表读取权限， w （2） 表示写入权限， x （1）表示执行权限。每个文件的访问权限都由9位组成，前面三位表示文件的所有者对文件的访问权限，中间3位 表示与所有者同组的其他用户对于该文件的访问权限，最后3位表示其他组的用户对于该文件的访问权限。“+” 表示授予权限，“-”表示收回权限。用户还可以指定执行权限授予的对象，其中u表示文件的所有者，g表示所有者所属的组，o表示其他组的用户。



#### 通过Shell脚本

将脚本文件作为参数传递给解释器，在通过这种方式执行脚本的时候，不需要用户拥有执行该脚本文件的权限，只要拥有读取该文件的权限即可。

#### source

读取指定的Shell程序文件，并且依次执行其中所有的语句，只是简单的读取脚本里面的语句，并且以此在当前的Shell里面执行，并没有创建新的子Shell进程。脚本里面创建的变量会保存到当前的Shell里面。



### 向脚本传递参数

#### 常用

| 变量名 | 说明                                                     |
| ------ | -------------------------------------------------------- |
| $n     | 表示传递给脚本的第n个参数， $1 表示第一个                |
| $#     | 命令行参数的个数                                         |
| $0     | 当前脚本的名称                                           |
| $*     | 以“参数1 参数2 参数3 ……”的形式返回所有参数的值           |
| $@     | 以“参数1“，” 参数2“，” 参数3“  ……”的形式返回所有参数的值 |
| $_     | 保存之前执行的命令的最后一个参数                         |



参数拓展

当程序需要一个拥有许多值的参数。单独的依靠 $1，$2等变量已经不能满足需求，以此，需要考虑参数拓展。为了获取这些参数的值，用户需要在Shell程序中使用 getopts 命令。

```shell
#! /bin/bash 
echo "OPTIND starts at $OPTIND"
while getopts ":pq:" optname
	do
	case "$optname" in
		"p")
		echo "option is $optname "
		;;
		"q")
		echo "option is $optname "
		;;
		"?")
		echo "option is $optname "
		;;
		":")
		echo "option is $optname "
		;;
		*)
		echo "UNKOWN error"
		;;
	esac
	echo "OPTIND is now $OPTIND"
done
```

optname 将接受找到选项的名称。

### Shell程序退出状态

在UNIX 或者 Linux 中，每个命令都会返回一个退出状态码。成功的命令返回0，不成功的命令返回 非0值。Shell脚本中的函数和脚本本身也会返回退出状态码。在脚本或者是脚本函数执行的最后的命令会决定退出状态码。另外，也可通过 exit （退出程序）语句将退出状态码传递给Shell。另外，在Shell中，系统变量 $？ 保存了最后一条命令的退出状态。
