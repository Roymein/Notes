# 数据结构与算法

## 第一章 数据结构和算法概述

### 1.1 数据结构分类

> 数据结构分为逻辑结构和物理结构。

逻辑结构：按照对象中数据元素之间的相互关系分类

- 集合结构

  数据元素除了属于同一个集合之外，无任何关系

- 线性结构

  元素之间存在一对一的关系

- 树形结构

  数据元素之间存在一对多的关系
  
- 图形结构

  数据元素是多对多的关系

  

物理结构：在计算机中真正的表达方式，也可以叫做存储结构。

顺序存储结构

​	把元素放在地址连续的存储单元中，数据间的逻辑关系和物理关系一致。但是存在一定的弊端：例如生活中排队时，有人插队，也有人突然离开，这时整个结构处于变化之中。

链式存储结构

​	将数据存放在任意的存储单元中，存储单元可以是连续的，也可以是不连续的。此时，数据元素之间不能元素之间的逻辑关系，因此在链式存储结构中引进了一个存放数据元素的地址，这样就可以通过地址找到相关联的数据元素的位置。



### 1.2 什么是算法

算法是解题方案的准确而完整的描述，一系列解决问题的清晰指令，算法代表用系统的方法解决问题的策略机制。也就是”根据一定的条件，对一些数据进行计算，得到需要的结果“。在程序中，我们可以用不同的算法解决相同的问题，而不同的算法的成本也是不同的。总体上，一个优秀的算法追求一下两个目标：

1. 花最少的时间完成需求。
2. 占用最少的内存空间完成需求。



## 第二章 算法分析

> 根据算法追求的两个目标，但是通常情况下我们不能将时间占用和空间占用量化，因此有时间复杂度及空间复杂度对以上进行描述

### 2.1 算法的时间复杂度分析

计算算法时间消耗，首先得度量算法的执行时间，那么如何度量呢？

**·** 事后分析估算方法：

​	比较容易的方法是我们将算法执行若干次，通过计算器进行计时，这种统计方法主要通过设计好的测试程序和测试数据，利用计算机计时器对不同的算法编制的程序的运行时间进行比较，从而确定算法的效率的高低。这种算法的主要缺陷是：必须依据算法实现编制好的测试程序，通常花费大量的时间和精力，测试完发现是非常糟糕的算法，那么之前所作的事情就白费了，并且不同的测试环境的差别导致测试结果差异也很大。

```java
public static void main(String[] args){
    long startTime = System.currentTimeMills();
    // todo sum
    int sum = 0;
    int n = 100;
    for (int i=1;i<=n;i++) {
        sum += i;
    }
    
    long endTime = System.currentTimeMills();
    System.out.printIn(endTime - startTime);
}
```



**·** 事前分析估算方法：

​	在计算机程序编写前，依据统计方法对算法进行估算，经过总结，发现一个高级语言编写的程序在计算机上所消耗的时间取决以下因素：

1. 算法采用的策略和方案
2. 编译产生的代码质量
3. 问题的输入规模（输入量的多少）
4. 机器执行指令的速度

由此可见，抛开硬件及软件的因素，一个程序运行的时间依赖于算法的好坏和问题的输入规模。如果算法固定，那么该算法的执行时间就只和问题的输入规模有关。



以求和为例：

解法一：

```java
//输入量为1，执行次数：1
//输入量为一亿，执行次数：1亿
public static void main(String[] args){   //执行2n+3次
    int sum = 0;				//执行1次
    int n = 100;				//执行1次
    for (int i=1;i<=n;i++) {	//执行n+1次
        sum += i;				//执行n次
    }
}
```

解法二：

```java
//输入量为1，执行次数：1
//输入量为一亿，执行次数：1次
public static void main(String[] args){
    int sum = 0;				//执行1次
    int n = 100;				//执行1次
    sum = (n+1)*n/2;			//执行1次
}
```

因此，当输入规模为n时，第一种算法执行了2n+3次，第二种算法执行了3次。如果把第一中算法的循环体看作一个整体，忽略结束条件的判断，两种算法的差距就是n和1的差距。

为何循环判断在算法一中执行了n+1次，看起来是个不小的数量缺可以忽略呢？

如：计算100个1+100个2+100个3+...+100个100的结果

```java
public static void main(String[] args){
    int sum = 0;
    int n = 100;
    for(int i = 1;i<=n;i++){
        for(int j = 1;j<=n; j++){
            sum += i;
        }
    }
}
```

以上代码中，精确研究循环的条件执行多少次是很麻烦的事情，并且，真正计算和的代码是内循环中的循环体，所以研究算法的效率时，我们只考虑核心代码的执行次数，这样可以简化分析。

研究算法复杂度，侧重的是当输入规模不断增大时，算法的增长量是一个抽象（规律），而不是精确地定位需要执行多少次，因为如果这样的话，我们又得考虑回编译期优化等问题，容易主次颠倒。

我们不关心编程语言是什么，程序运行在什么计算机上，只关心它所实现的算法。这样，不计那些循环索引的递增和循环终止条件、变量声明、打印结果等操作，最终在分析程序的运行时间时，最终要的是把程序看作是独立于程序设计语言的算法或一系列步骤。我们分析一个算法，最重要的是将核心操作的次数和输入规模关联起来。

#### 2.1.1 函数渐进增长

概念：给定两个函数 f (n) 和 g (n) ，如果存在一个整数 N，使得当 n>N时，f（n）总是大于 g（n）时，则 f（n）的增长渐进快于 g（n）。







### 2.2 算法的空间复杂度分析



## 第三章



## 第四章



## 第五章



## 第六章