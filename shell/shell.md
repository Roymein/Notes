###### echo

> 彩色输出：重置=0，黑色=30，红色=31，绿色=32，黄色=33，蓝色=34，洋红=35，青色=36，白色=37  
> 彩色背景：颜色码是：重置=0，黑色=40，红色=41，绿色=42，黄色=43，蓝色=44，洋红=45，青色=46，白色=47

```
-n 禁用换行（echo会将一个换行符追加到输出文本的尾部）
-e 使用转义序列
e[1;31m   \e[0m颜色重新置回。

echo -e "\e[1;42m Green Background \e[0m"
printf或echo命令的双引号中引用变量值
```



###### 变量与环境变量

> 变量是任何一种编程语言必不可少的组成部分，用于存放各类数据。脚本语言通常不
> 需要在使用变量之前声明其类型。只需要直接赋值就可以了。在Bash中，每一个变量的值
> 都是字符串。无论你给变量赋值时有没有使用引号，值都会以字符串的形式存储。有一些特殊的变量会被shell环境和操作系统环境用来存储一些特别的值，这类变量就被称为环境
> 变量。
>
> 
>
> HOME、PWD、USER、UID、SHELL



```
export 导出特定的变量，用来设置环境变量
```



###### tr

> 转换或删除文件中的字符



##### 数学运算

###### let

> 用于执行一个或多个表达式，变量计算中不需要加上 `$` 来表示变量，如果表达式中包含了空格或其他特殊字符，则必须引起来

```
let num1+num2
```



###### expr

> 求表达式变量的值，一般用于整数值，也可用于字符串。

```
expr 5 + 10
```



###### bc

> 类似基本的计算器, 可以做基本的数学运算

```
echo "5+10" | bc
```

进制转换

```
ibase 是 input base 的缩写，表示输入数字的进制模式 obase 是 output base 的缩写，表示输出数字的进制模式
abc=110011100 
echo "obase=10;ibase=2;$abc" | bc
```



文件描述符与重定向

> 最常见的文件描述符是stdin、stdout和stderr。我们可以将某个文件描述符的内容重定向到另一个
> 文件描述符中。文件描述符是与一个打开的文件或数据流相关联的整数。

> 通过内容过滤将输出重定向到文件是我们从事的基础任务之一。当命令输
> 出文本的时候，这些输出文本有可能是错误信息，也可能是正常的（非错误的）输出信
> 息。单靠查看输出的文本本身，我们没法区分哪些是正常的输出文本，哪些是错误文本。
> 不过，我们可以通过文件描述符来解决这个问题，将那些与特定描述符关联的文本提取出
> 来。

□ 0 —— stdin（标准输入）。
□ 1 —— stdout（标准输出）。
□ 2 —— stderr（标准错误）

> 成功和不成功的命令
> 当一个命令发生错误并退回时，它会返回一个非0的退出状态；而当命令成功完成
> 后，它会返回数字0。退出状态可以从特殊变量 ?中获得（在命令执行语句之后立刻运
> 行echo ?，就可以打印出退出状态）。
>
> cmd 2＞stderr.txt 1＞stdout.txt





###### 管道

> 将两个或者多个命令（程序或者进程）连接到一起，把**一个命令的输出作为下一个命令的输入**，以这种方式连接的两个或者多个命令就形成了**管道（pipe）**。管道使用竖线**`|`**连接多个命令，这被称为管道符



tee

> tee 命令用于读取标准输入的数据，并将其内容输出成文件
>
> （接收到来自stdin的数据。它将stdout的一份副本写入文件）



## Shell基础

### 执行Shell程序

#### 脚本设置可执行

ls -l 可查看文件的访问权限。r （4）代表读取权限， w （2） 表示写入权限， x （1）表示执行权限。每个文件的访问权限都由9位组成，前面三位表示文件的所有者对文件的访问权限，中间3位 表示与所有者同组的其他用户对于该文件的访问权限，最后3位表示其他组的用户对于该文件的访问权限。“+” 表示授予权限，“-”表示收回权限。用户还可以指定执行权限授予的对象，其中u表示文件的所有者，g表示所有者所属的组，o表示其他组的用户。



#### 通过Shell脚本

将脚本文件作为参数传递给解释器，在通过这种方式执行脚本的时候，不需要用户拥有执行该脚本文件的权限，只要拥有读取该文件的权限即可。

#### source

读取指定的Shell程序文件，并且依次执行其中所有的语句，只是简单的读取脚本里面的语句，并且以此在当前的Shell里面执行，并没有创建新的子Shell进程。脚本里面创建的变量会保存到当前的Shell里面。



### 向脚本传递参数

#### 常用

常用系统变量

| 变量名 | 说明                                                         |
| ------ | ------------------------------------------------------------ |
| $n     | 表示传递给脚本的第n个参数， $1 表示第一个， n 取值范围为 1-9 |
| $#     | 命令行参数的个数                                             |
| $0     | 当前脚本的名称                                               |
| $*     | 以“参数1 参数2 参数3 ……”的形式返回所有参数的值               |
| $@     | 以“参数1“，” 参数2“，” 参数3“  ……”的形式返回所有参数的值     |
| $_     | 保存之前执行的命令的最后一个参数                             |
| $?     | 前一个命令或者函数的返回状态码                               |
| $$     | 返回本程序的进程ID  （PID）                                  |
|        |                                                              |



参数拓展

当程序需要一个拥有许多值的参数。单独的依靠 $1，$2等变量已经不能满足需求，以此，需要考虑参数拓展。为了获取这些参数的值，用户需要在Shell程序中使用 getopts 命令。

```shell
#! /bin/bash 
echo "OPTIND starts at $OPTIND"
while getopts ":pq:" optname
	do
	case "$optname" in
		"p")
		echo "option is $optname "
		;;
		"q")
		echo "option is $optname "
		;;
		"?")
		echo "option is $optname "
		;;
		":")
		echo "option is $optname "
		;;
		*)
		echo "UNKOWN error"
		;;
	esac
	echo "OPTIND is now $OPTIND"
done
```

optname 将接受找到选项的名称。

### Shell程序退出状态

在UNIX 或者 Linux 中，每个命令都会返回一个退出状态码。成功的命令返回0，不成功的命令返回 非0值。Shell脚本中的函数和脚本本身也会返回退出状态码。在脚本或者是脚本函数执行的最后的命令会决定退出状态码。另外，也可通过 exit （退出程序）语句将退出状态码传递给Shell。另外，在Shell中，系统变量 $？ 保存了最后一条命令的退出状态。



### vi 编辑器

vi 有三种模式，一般模式，编辑模式，命令模式

#### 一般模式

用户刚进入vi 编辑器的时候就是一般模式。使用 Esc 键可以返回到一般模式。用户在一般模式下，可通过 " / " 进入文本搜索模式。

表1 光标移动快捷键

| 操作             | 快捷键           |
| ---------------- | ---------------- |
| 向上移动         | k 或者 backsoace |
| 向下移动         | j 或者 空格键    |
| 向左移动         | h                |
| 向右移动         | l                |
| 移至下一行行首   | 回车键           |
| 移至上一行行首   | - 键             |
| 移至文件最后一行 | G 键             |

表2 文本操作快捷键

| 操作     | 快捷键                                            |
| -------- | ------------------------------------------------- |
| 右插入   | a                                                 |
| 左插入   | i                                                 |
| 行尾追加 | A                                                 |
| 行首插入 | I                                                 |
| 插入行   | O （上面插入一个新行）或者 o （下面插入一个新行） |
| 覆盖文本 | R 覆盖当前光标所在位置以及后面的若干文本          |
| 合并行   | J 将当前光标所在行与下面一行合并为一行            |

表3 文本复制和粘贴快捷键

| 操作                 | 快捷键                                 |
| -------------------- | -------------------------------------- |
| 复制行               | yy                                     |
| 复制多行             | nyy 将当前行以及下面的 n行复制到缓冲区 |
| 复制单词             | yw                                     |
| 复制多个单词         | nyw                                    |
| 复制光标到行首       | y^                                     |
| 复制光标到行尾       | y$                                     |
| 粘贴到光标后面的位置 | p                                      |
| 粘贴到光标前面的位置 | P                                      |

表4 删除文本快捷键

| 操作           | 快捷键 |
| -------------- | ------ |
| 删除当前字符   | x      |
| 删除多个字符   | nx     |
| 删除当前行     | dd     |
| 删除多个行     | ndd    |
| 撤销上一步操作 | u      |
| 撤销多个操作   | U      |



#### 编辑模式

表2 中除了J键之外的任何快捷键，都会进入编辑模式。



#### 命令模式

在命令模式下，用户主要完成文件的打开、保存、将光标跳转至某行、以及显示行号等操作。命令模式需要从一般模式进入，在一般模式下，按冒号键之后，编辑器底部会出现提示符。“！”在vi编辑器中表示跳过某些检查，强制执行某些操作。

表5 常用命令

| 操作           | 命令                                                        |
| -------------- | ----------------------------------------------------------- |
| 打开文件       | :e 文件名作为参数                                           |
| 保存文件       | :w                                                          |
| 退出编辑器     | :q                                                          |
| 直接退出编辑器 | :q! 不保存修改，直接退出vi编辑器                            |
| 退出并保存文件 | :wq                                                         |
| 跳至指定行     | :n(跳至行号为n的行)  :n+ 或 :n-  （+向下跳n行，-向上跳n行） |
| 显示或隐藏行号 | :set nu :set nonu                                           |
| 替换字符串     | :s/old/new :s/olg/new/g                                     |
| 设置文件格式   | :set fileformat=unix                                        |



### 命令别名

.bashrc 主要用来定义别名和函数。

命令别名是命令的另外一个名称，主要作用是简化命令的输入。当设置了命令别名之后，用户就可以像使用普通的命令一样使用别名。

```shell
alias command_alias=command
```





## Shell 编程基础

### 1 变量

在程序中保存用户数据的一块内存空间，变量名就是这块内存空间的地址。

类型：

静态类型语言 和 动态类型语言-> 在程序编译期间是否需要确定变量类型的语言。

强类型语言 和 弱类型语言 -> 在定义变量时是否需要确定其数据类型。



Shell 变量中的符号 “$"表示取变量的值， 只有在取值的时候才使用，定义和赋值时无需使用符号  ”$“。 Shell 中变量的原型为 ${var}，$var 为简写。



1.1  变量的定义

如果变量的值包含空格，需要用引号包含起来。

```shell
a="this is "
```



1.2 declare

```shell
declare attribute variable
```



用于控制变量的相关属性，如变量的类型，读写属性。attribute 表示变量的属性。参数variable表示变量名称。

-p：显示所有的变量的值

-i：将变量定义为整型。在之后即可对表达式求值，结果只能是整数。

-r：声明为只读变量，不允许修改，也不允许删除

-a：声明为数组变量，

-f：显示自定义函数，包括名称和函数体。

-x：将变量设置为环境变量，这样在随后的脚本和程序中可以使用。



1.3 引号

| 符号 | 作用                                                         |
| ---- | ------------------------------------------------------------ |
| ' '  | 括号内的符号作为普通字符使用                                 |
| " "  | 除了 $  \   `   "  是特殊字符并保留其特殊功能外，其余字符仍旧作为普通字符对待。 |
| `    | 由反引号引起来的字符串被shell 解释为命令，在执行时，Shell首先执行该命令，并以其标准输出结果来取代整个反引号。 |

```shell
#！ bin/bash

echo "current directory is `pwd`"
```

shell 中的 \  为转义字符。将特殊符号转为普通符号



1.4 变量的作用域

1.4.1 全局变量

全局变量可以在脚本中定义，也可以在某个函数中定义。

-  在脚本中定义的变量都是全局变量，其作用域是被定义的地方开始，一直到shell脚本结束或者显式的删除。

- 在函数中定义的全局变量，作用域为从函数被执行变量定义的地方开始，一直到 shell 脚本结束或者显式地删除为止。



1.4.2 局部变量

可以在函数内部使用 **local** 关键字显式的定义局部变量，通常仅限于某个程序段访问，例如在函数内部。



1.4.3 系统变量

参考 前文 系统变量表格。



1.4.4 环境变量

| 变量     | 说明                           |
| -------- | ------------------------------ |
| PATH     | 命令搜索路径，以冒号为分隔符。 |
| HOME     | 用户主目录的路径名，           |
| LOGNAME  | 登录名                         |
| PWD      | 当前工作目录                   |
| HISTFILE | 命令历史文件                   |
|          |                                |
|          |                                |

除了以上列出的环境变量之外，还可通过以下命令列出所有环境变量：

```shell

set | more
```



2、 变量赋值和清空





